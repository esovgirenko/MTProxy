#!/usr/bin/env bash
# =============================================================================
# MTProto Proxy Installer for Ubuntu 22.04/24.04
# Uses alexbers/mtprotoproxy (maintained Python implementation).
# One-liner: curl -s https://your-domain.com/install.sh | sudo bash
# Customize: PORT=9123 AD_TAG="your-tag" ./install.sh
# Optional:  ./install.sh --enable-auto-update
# =============================================================================
# DISCLAIMER: Running a proxy may have legal/ToS implications. Use at your own
# risk. Ensure compliance with Telegram ToS and local laws.
# =============================================================================

set -euo pipefail
IFS=$' \n\t'

# --- Constants ---
readonly INSTALL_DIR="/opt/mtprotoproxy"
readonly SERVICE_NAME="mtprotoproxy"
readonly PROXY_USER="mtproto-proxy"
readonly REPO_URL="https://github.com/alexbers/mtprotoproxy.git"
readonly REPO_BRANCH="stable"
readonly PORT_MIN=9000
readonly PORT_MAX=9999
readonly MIN_DISK_MB=100

# --- Colors (no-op if not a TTY) ---
if [[ -t 1 ]]; then
  readonly RED='\033[0;31m' GREEN='\033[0;32m' YELLOW='\033[1;33m' NC='\033[0m'
else
  readonly RED='' GREEN='' YELLOW='' NC=''
fi

info()  { echo -e "${GREEN}[INFO]${NC} $*"; }
warn()  { echo -e "${YELLOW}[WARN]${NC} $*"; }
err()   { echo -e "${RED}[ERROR]${NC} $*"; }

# --- Rollback tracking ---
ROLLBACK_ITEMS=()
rollback() {
  for item in "${ROLLBACK_ITEMS[@]}"; do
    if [[ -e "$item" ]]; then
      rm -rf "$item" && warn "Rollback: removed $item"
    fi
  done
}
trap 'e=$?; [[ $e -ne 0 ]] && rollback; exit $e' EXIT

# --- Pre-flight checks ---
preflight() {
  [[ $(id -u) -eq 0 ]] || { err "Must run as root (e.g. sudo bash)"; exit 1; }
  if [[ -f /etc/os-release ]]; then
    . /etc/os-release
    case "$ID" in
      ubuntu) ;;
      *) err "Unsupported OS: $ID. This script targets Ubuntu 22.04/24.04."; exit 1 ;;
    esac
    # Optional: strict version check
    # [[ "$VERSION_ID" == "22.04" || "$VERSION_ID" == "24.04" ]] || warn "Tested on 22.04/24.04; you have $VERSION_ID"
  else
    err "Cannot detect OS."; exit 1
  fi
  local avail_mb
  avail_mb=$(df -m / | awk 'NR==2 {print $4}')
  [[ "${avail_mb:-0}" -ge "$MIN_DISK_MB" ]] || { err "Insufficient disk space (need >= ${MIN_DISK_MB}MB)"; exit 1; }
}

# --- Resolve port (env PORT or random in range with collision check) ---
resolve_port() {
  if [[ -n "${PORT:-}" && "$PORT" =~ ^[0-9]+$ && "$PORT" -ge "$PORT_MIN" && "$PORT" -le "$PORT_MAX" ]]; then
    echo "$PORT"
    return
  fi
  local p
  for (( i = 0; i < 50; i++ )); do
    p=$(( PORT_MIN + (RANDOM % (PORT_MAX - PORT_MIN + 1)) ))
    if ! command -v ss &>/dev/null; then
      echo "$p"
      return
    fi
    if ! ss -ltn 2>/dev/null | grep -q ":${p} "; then
      echo "$p"
      return
    fi
  done
  echo "$PORT_MIN"
}

# --- Generate 32-char hex secret; link secret = dd/ee + 32 hex ---
generate_secret() {
  local hex
  hex=$(openssl rand -hex 16)
  if [[ -n "${AD_TAG:-}" ]]; then
    echo "dd${hex}"
  else
    echo "ee${hex}"
  fi
}

# --- Install dependencies and clone proxy ---
install_proxy() {
  export DEBIAN_FRONTEND=noninteractive
  apt-get update -qq
  apt-get install -y -qq git python3 python3-pip python3-venv >/dev/null

  if [[ -d "$INSTALL_DIR" ]]; then
    (cd "$INSTALL_DIR" && git fetch -q origin && git checkout -q "$REPO_BRANCH" && git pull -q --ff-only 2>/dev/null || true)
  else
    git clone -b "$REPO_BRANCH" --depth 1 "$REPO_URL" "$INSTALL_DIR"
    ROLLBACK_ITEMS+=("$INSTALL_DIR")
  fi

  python3 -m pip install --break-system-packages -q cryptography uvloop 2>/dev/null || \
  python3 -m pip install -q cryptography uvloop 2>/dev/null || true
}

# --- Create non-privileged user ---
ensure_user() {
  if ! getent passwd "$PROXY_USER" &>/dev/null; then
    useradd --no-create-home -s /usr/sbin/nologin "$PROXY_USER"
  fi
}

# --- Write config.py (secret = 32 hex for USERS; link uses dd/ee prefix) ---
write_config() {
  local port="$1" link_secret="$2"
  local secret_hex="${link_secret#??}"  # strip ee or dd
  cat > "$INSTALL_DIR/config.py" << EOF
# Generated by install.sh - do not edit manually
PORT = $port
USERS = {"tg": "$secret_hex"}
MODES = {"classic": False, "secure": False, "tls": True}
TLS_DOMAIN = "www.cloudflare.com"
EOF
  if [[ -n "${AD_TAG:-}" ]]; then
    echo "AD_TAG = \"$AD_TAG\"" >> "$INSTALL_DIR/config.py"
  fi
  chown "$PROXY_USER:$PROXY_USER" "$INSTALL_DIR/config.py"
  chmod 600 "$INSTALL_DIR/config.py"
}

# --- Idempotent: load existing port/secret from config if present ---
load_existing_config() {
  [[ -f "$INSTALL_DIR/config.py" ]] || return 1
  local port_line secret_hex
  port_line=$(grep -E '^PORT\s*=' "$INSTALL_DIR/config.py" 2>/dev/null | sed 's/.*=\s*//;s/\s*//g')
  secret_hex=$(grep -oE '"[0-9a-f]{32}"' "$INSTALL_DIR/config.py" 2>/dev/null | head -1 | tr -d '"')
  if [[ -n "${port_line:-}" && "$port_line" =~ ^[0-9]+$ && -n "${secret_hex:-}" ]]; then
    echo "$port_line"
    if grep -q 'AD_TAG' "$INSTALL_DIR/config.py" 2>/dev/null; then
      echo "dd${secret_hex}"
    else
      echo "ee${secret_hex}"
    fi
    return 0
  fi
  return 1
}

# --- Systemd unit with sandboxing ---
install_systemd() {
  cat > "/etc/systemd/system/${SERVICE_NAME}.service" << EOF
[Unit]
Description=MTProto Proxy for Telegram (alexbers/mtprotoproxy)
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
User=$PROXY_USER
Group=$PROXY_USER
WorkingDirectory=$INSTALL_DIR
ExecStart=/usr/bin/python3 $INSTALL_DIR/mtprotoproxy.py $INSTALL_DIR/config.py
Restart=on-failure
RestartSec=5
PrivateTmp=yes
NoNewPrivileges=yes
ProtectSystem=strict
ProtectHome=yes
ReadWritePaths=$INSTALL_DIR
PrivateDevices=yes
RestrictAddressFamilies=AF_INET AF_INET6
LimitNOFILE=65535

[Install]
WantedBy=multi-user.target
EOF
  systemctl daemon-reload
  systemctl enable --now "$SERVICE_NAME"
}

# --- UFW: allow proxy port (external only; bind is 0.0.0.0, firewall limits as needed) ---
configure_firewall() {
  if command -v ufw &>/dev/null; then
    ufw allow "$1/tcp" comment "MTProto proxy" 2>/dev/null || true
    [[ "$(ufw status)" =~ "inactive" ]] || ufw --force enable 2>/dev/null || true
  fi
}

# --- Logrotate ---
install_logrotate() {
  cat > "/etc/logrotate.d/${SERVICE_NAME}" << EOF
/var/log/${SERVICE_NAME}.log {
    weekly
    rotate 4
    missingok
    notifempty
    copytruncate
}
EOF
  # Ensure service can log if we add logging later
  touch /var/log/${SERVICE_NAME}.log 2>/dev/null || true
  chown "$PROXY_USER:$PROXY_USER" /var/log/${SERVICE_NAME}.log 2>/dev/null || true
}

# --- Validate proxy (health check for monitoring) ---
validate_proxy() {
  local port="$1" i
  for (( i = 0; i < 10; i++ )); do
    sleep 1
    if (echo >/dev/tcp/127.0.0.1/"$port") 2>/dev/null || ss -ltn 2>/dev/null | grep -q ":${port} "; then
      return 0
    fi
  done
  return 1
}

# --- Public IP for connection string ---
get_public_ip() {
  curl -s --max-time 3 -4 ifconfig.me 2>/dev/null || curl -s --max-time 3 -4 icanhazip.com 2>/dev/null || hostname -I 2>/dev/null | awk '{print $1}'
}

# --- Optional: enable auto-update (apt + proxy repo pull) ---
enable_auto_update() {
  local cron="/etc/cron.weekly/mtprotoproxy-update"
  cat > "$cron" << 'CRON'
#!/bin/bash
apt-get update -qq && apt-get install -y -qq --only-upgrade python3 python3-pip 2>/dev/null || true
cd /opt/mtprotoproxy && git pull -q --ff-only 2>/dev/null || true
systemctl try-restart mtprotoproxy 2>/dev/null || true
CRON
  chmod +x "$cron"
}

# --- Main ---
main() {
  local enable_auto_update_flag=false
  for arg in "$@"; do
    [[ "$arg" == "--enable-auto-update" ]] && enable_auto_update_flag=true
  done

  preflight
  info "Starting MTProto proxy installation..."

  ensure_user
  install_proxy

  local port link_secret existing
  existing=($(load_existing_config 2>/dev/null))
  if [[ ${#existing[@]} -ge 2 ]]; then
    port="${existing[0]}"
    link_secret="${existing[1]}"
    info "Using existing config (idempotent run). Port=$port"
  else
    resolved_port=$(resolve_port)
    port="${PORT:-$resolved_port}"
    link_secret=$(generate_secret)
    write_config "$port" "$link_secret"
  fi

  install_systemd
  configure_firewall "$port"
  install_logrotate

  if [[ "$enable_auto_update_flag" == true ]]; then
    enable_auto_update
    info "Auto-update (weekly) enabled."
  fi

  if ! validate_proxy "$port"; then
    err "Proxy may not be listening yet. Check: systemctl status $SERVICE_NAME"
  fi

  local ip
  ip=$(get_public_ip)
  echo ""
  echo -e "${GREEN}âœ… MTProto Proxy successfully installed!${NC}"
  echo ""
  echo "ðŸ“± Telegram connection link:"
  echo "tg://proxy?server=${ip}&port=${port}&secret=${link_secret}"
  echo ""
  echo "ðŸ”‘ Secret key: ${link_secret}"
  echo "ðŸšª Port: ${port}"
  echo "ðŸ“Š Stats URL: http://${ip}:${port}/stats (if supported)"
  echo ""
  echo "Service: systemctl status $SERVICE_NAME | Logs: journalctl -u $SERVICE_NAME -f"
  echo "Health:  nc -zv $ip $port  # TCP port check for monitoring"
  echo "DISCLAIMER: Ensure proxy usage complies with Telegram ToS and local laws."
}

main "$@"
